\2 {\[Svace\] Поиск ошибок доступа к буферу в программах на языке C/C++} {paper_svace_buffer}

\paperblock {svace_buffer}

\quote {2016+. И.~А.~Дудина, В. К. Кошелев, А. Е. Бородин. Ещё не опубликована. См. \ref {#svace} {Svace}.}

\page {1} Здесь определяются достаточные условия выхода за границы массива. \comment {Но нам нужны необходимые?} \page {2} Задача в общем случае алгоритмически неразрешима. \page {3} Рассматриваются только \i {константные} буферы (размер известен на момент компиляции). \page {4} Каждая функция считается точкой входа в программу, для поиска дефектов во всех потенциальных контекстах вызова (а не только на уже существующих). (Это актуально в основном для библиотечных функций.) \i {Неизвестные переменные} функции: входные параметры, начальное состояние памяти, результаты вызываемых функций. Ограничения на множество \abbr {НП} — \i {контракт}.

\page {5} По условию, контракты не известны. Но для каждой ошибки можно подобрать такой к функции контракт, что ошибка исчезнет. Поэтому они будут пытаться искать такие ошибки, которые зависят от свойств \abbr {ГПУ} {графа потока управления} (есть путь, на котором ошибка гарантировано будет), но не зависят от множества \abbr {НП} {неизвестных переменных}. \page {6} Контракты не должны сужать множество выполнимых путей.

\page {7} Ядро \ref {#svace} {Svace} проводит символьное исполнение программы с объединением состояний. \page {8} Решение: в~ходе символьного исполнения проводить \abbr {VSA} {value set analysis}, проверять выполнимость формулы потенциального дефекта (\comment {т.~е.~они делают то же самое, что и мы, только в статике}):

ReachCond(instr) and (NotLess(instr, index, size) or NotGreater(instr, index, -1))

\page {14} При реализации в качестве инструкций доступа к буферу рассматривались обычные инструкции индексации и вызовы библиотечных функций (например, \m {memcpy}).

\[Выше уже было отмечено, что\]
\[т.е., т.о.\]
\[путь на ГПУ ? в ГПУ\]

\pages {18 pages}

