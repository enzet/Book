\2 {Driller: Augmenting Fuzzing Through Selective Symbolic Execution} {paper_driller}

\paperblock {driller}

\tag {#fuzzing} \tag {#concolic}.

It was built for \ref {#darpacgc} {\abbr {DARPA} Cyber Grand Challenge}.

\b {Idea}: decompose application to different compartments; fuzz inside compartment, use concolic to walk between compartments.

\page {1} Driller is for vulenrability excavation using fuzzing and selective concolic (to go deeper). Concolic is used for conditions that the fuzzer cannot satisfy. \comment {They divide analysis approaches into 3 categories: static, dynamic (they mean single run, actually), and concolic.} \page {2} Concolic usually fix the depth but fuzzers usually fail to pass through input-processing code. They propose \i {general} (unlimited set of values) and \i {specific} (limited) inputs. Application's checks for paticular input values may split execution into \i {compartments} (like reading commands from input). Fuzzing is useful \i {inside} compartment, not \i {between} them. \page {3} \ref {#dowser} {Dowser} uses static analysis to identity regions and detect input bytes for defects in this regions using taint tracking. But it requires test cases to reach this regions. Almost same is \ref {#buzzfuzz} {BuzzFuzz}. \ref {#flayer} {Flayer} allows auditor to skip complex checks. They said blind using of concolic on inputs generated by fuzzing does not work without insight about different compartments of application (because inside compartment concolic is redundant). \comment {See \ref {#paper_veritesting} {Veritesting} and \ref {#paper_firmalice} {Firmalice}.}

\page {4} Driller assumes that application is dividable into compartments. Corner example is magic number checking. Fuzzing just means minimal instrumentation. \page {5} They use \ref {#afl} {\abbr {AFL}} as a fuzzer. \page {6} Stuck is when fuzzer has gone through a predetermined amount (proportional to the input length) of mutations without identifying new states. They use \ref {#angr} {angr} as a concolic execution engine. It translates binary code into \ref {#valgrind} {Valgrind}'s \abbr {VEX}. They use approach popularized by \ref {#mayhem} {Mayhem}: memory model can store both concrete and symbolic values; read addresses may be symbolic, but write address are always concretized. \comment {Very importaint!}

\page {7} When a crashing input is found by fuzzer, concolic engine “re-randomizes” it to recover the parts are dependent on randomness and other environmental factors.

\page {14} They said their representation of state is imperfect. As I understand, \m {if} may be not interesting for inversion when Driller needs to invert it second time. \page {15} When program use input as \i {generic} and \i {specific} simultaneously: check magic number and check it's hash. Concolic gives magic number but it does not say about dependency between this number and it's hash. So, fuzzer mutates this number and never found proper hash. \comment {Pretty interesting!} They want to generate “semi-symbolic” fuzzing input (set of constraints on input) or create generational fuzzing (produce not just inputs but input generators).

